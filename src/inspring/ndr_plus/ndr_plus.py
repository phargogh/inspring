"""Primary script for NDR plus."""
from osgeo import gdal

def ndr_watershed_processing(
        watershed_path, watershed_fid,
        target_cell_size,
        routing_algorithm,
        dem_path,
        eff_n_lucode_map,
        load_n_lucode_map,
        target_export_raster_path,
        target_modified_load_raster_path,
        workspace_dir):
    """Process a watershed for NDR analysis.

    Args:
        watershed_path (str): path to watershed vector
        watershed_fid (str): watershed FID to run the analysis on.
        target_cell_length (float): length of target cell size to process
            in meters.
        routing_algorithm (str): one of 'D8' or 'DINF' for D8 or D-infinity
            routing.
        dem_path (str): path to base DEM raster.
        lulc_path (str): path to LULC raster.
        precip_path (str): path to precipitation raster.
        custom_load_path (str): path to load raster to use on given values
            TODO: say what these values are.
        eff_n_lucode_map (dict): maps lucodes to NDR efficiency values.
        load_n_lucode_map (dict): maps lucodes to NDR load values.
        workspace_dir (str): path to workspace to create working files.
        aligned_file_set (set): set of all output files generated by align
            and resize raster stack.

    Returns:
        None.
    """
    watershed_vector = gdal.OpenEx(watershed_path, gdal.OF_VECTOR)
    watershed_layer = watershed_vector.GetLayer()
    watershed_feature = watershed_layer.GetFeature(watershed_fid)
    watershed_fid = watershed_feature.GetFID()

    # make a few subdirectories so we don't explode on number of files per
    # directory. The largest watershed is 726k
    last_digits = '%.4d' % watershed_fid
    ws_working_dir = os.path.join(
        workspace_dir, last_digits[-1], last_digits[-2],
        last_digits[-3], last_digits[-4],
        "%s_working_dir" % ws_prefix)
    os.makedirs(ws_working_dir, exist_ok=True)

    watershed_dem_path = os.path.join(
        ws_working_dir, '%s_dem.tif' % ws_prefix)

    watershed_geometry = watershed_feature.GetGeometryRef()
    watershed_bb = [
        watershed_geometry.GetEnvelope()[i] for i in [0, 2, 1, 3]]

    global_dem_info = pygeoprocessing.get_raster_info(dem_path)
    create_watershed_dem_task = task_graph.add_task(
        func=pygeoprocessing.warp_raster,
        args=(
            dem_path, global_dem_info['pixel_size'],
            watershed_dem_path, 'near'),
        kwargs={'target_bb': watershed_bb},
        target_path_list=[watershed_dem_path],
        task_name='create_watershed_dem_%s' % ws_prefix)

    masked_watershed_dem_path = watershed_dem_path.replace(
        '.tif', '_masked.tif')

    centroid_geom = watershed_geometry.Centroid()
    utm_code = (math.floor((centroid_geom.GetX() + 180)/6) % 60) + 1
    lat_code = 6 if centroid_geom.GetY() > 0 else 7
    epsg_code = int('32%d%02d' % (lat_code, utm_code))
    epsg_srs = osr.SpatialReference()
    epsg_srs.ImportFromEPSG(epsg_code)
    pixel_area_in_km2 = UTM_PIXEL_SIZE ** 2 / 1.e3**2

    watershed_geometry = None
    watershed_layer = None
    watershed_vector = None

    local_watershed_path = os.path.join(ws_working_dir, '%s.gpkg' % ws_prefix)

    reproject_watershed_task = task_graph.add_task(
        func=reproject_geometry_to_target,
        args=(
            watershed_path, watershed_fid, epsg_srs.ExportToWkt(),
            local_watershed_path),
        target_path_list=[local_watershed_path],
        task_name='project_watershed_%s' % ws_prefix)

    mask_watershed_dem_task = task_graph.add_task(
        func=mask_raster_by_vector,
        args=(
            watershed_dem_path, local_watershed_path,
            masked_watershed_dem_path),
        target_path_list=[masked_watershed_dem_path],
        dependent_task_list=[
            reproject_watershed_task, create_watershed_dem_task],
        task_name='mask dem %s' % ws_prefix)

    base_raster_path_list = sorted(list(set(
        [os.path.join(root_data_dir, path)
         for (path, _) in list(LANDCOVER_RASTER_PATHS.values())] +
        [os.path.join(root_data_dir, path)
         for path in list(PRECIP_RASTER_PATHS.values()) +
         list(AG_RASTER_PATHS.values()) +
         list(POPULATION_RASTER_PATHS.values())])))
    base_raster_path_list.extend(
        [gpw_2010_total_dens_path, masked_watershed_dem_path])

    max_basename_length = 40

    def _base_to_aligned_path_op(base_path):
        """Convert global raster path to local."""
        return os.path.join(
            ws_working_dir, '%s_%s_aligned.tif' % (
                ws_prefix,
                os.path.splitext(
                    os.path.normpath(base_path).replace(
                        os.sep, '_'))[0].replace(
                    ws_prefix, '')[-max_basename_length:]))

    aligned_path_list = [
        _base_to_aligned_path_op(path) for path in base_raster_path_list]
    aligned_dem_path = aligned_path_list[-1]
    gpw_2010_den_aligned_path = aligned_path_list[-2]

    wgs84_sr = osr.SpatialReference()
    wgs84_sr.ImportFromEPSG(4326)
    target_bounding_box = pygeoprocessing.transform_bounding_box(
        watershed_bb, wgs84_sr.ExportToWkt(),
        epsg_srs.ExportToWkt())

    # clip dem, precip, & landcover to size of DEM? use 'mode'
    # we know the input rasters are WGS84 unprojected

    if any((x in aligned_file_set for x in aligned_path_list)):
        raise ValueError(
            "%s files might be duplicately processed", aligned_path_list)
    aligned_file_set.update(aligned_path_list)

    landcover_basename_set = set(
        [os.path.basename(path)
         for path, _ in LANDCOVER_RASTER_PATHS.values()])

    interpolation_mode_list = []
    for path in base_raster_path_list:
        if os.path.basename(path) in landcover_basename_set:
            interpolation_mode_list.append('mode')
        else:
            interpolation_mode_list.append('near')

    align_resize_task = task_graph.add_task(
        func=pygeoprocessing.align_and_resize_raster_stack,
        args=(
            base_raster_path_list, aligned_path_list,
            interpolation_mode_list,
            (UTM_PIXEL_SIZE, -UTM_PIXEL_SIZE),
            target_bounding_box),
        kwargs={'target_projection_wkt': epsg_srs.ExportToWkt()},
        target_path_list=aligned_path_list,
        dependent_task_list=[mask_watershed_dem_task],
        task_name='align resize %s' % ws_prefix)

    masked_gpw_2010_den_path = _base_to_aligned_path_op(
        os.path.join(workspace_dir, 'masked_gpw_2010_den.tif'))
    mask_gpw_2010_task = task_graph.add_task(
        func=mask_raster_by_vector,
        args=(
            gpw_2010_den_aligned_path, local_watershed_path,
            masked_gpw_2010_den_path),
        target_path_list=[masked_gpw_2010_den_path],
        dependent_task_list=[
            reproject_watershed_task, align_resize_task],
        task_name='mask gpw %s' % ws_prefix)

    # fill and route dem
    filled_watershed_dem_path = os.path.join(
        ws_working_dir, '%s_dem_filled.tif' % ws_prefix)
    flow_dir_path = os.path.join(
        ws_working_dir, '%s_flow_dir.tif' % ws_prefix)

    fill_pits_task = task_graph.add_task(
        func=pygeoprocessing.routing.fill_pits,
        args=(
            (aligned_dem_path, 1),
            filled_watershed_dem_path),
        kwargs={'working_dir': ws_working_dir},
        target_path_list=[
            filled_watershed_dem_path],
        dependent_task_list=[align_resize_task],
        task_name='fill pits %s' % ws_prefix)

    flow_dir_task = task_graph.add_task(
        func=pygeoprocessing.routing.flow_dir_d8,
        args=(
            (filled_watershed_dem_path, 1),
            flow_dir_path),
        kwargs={'working_dir': ws_working_dir},
        target_path_list=[
            flow_dir_path],
        dependent_task_list=[fill_pits_task],
        task_name='flow dir %s' % ws_prefix)

    # flow accum dem
    flow_accum_path = os.path.join(
        ws_working_dir, '%s_flow_accum.tif' % ws_prefix)
    flow_accum_task = task_graph.add_task(
        func=pygeoprocessing.routing.flow_accumulation_d8,
        args=(
            (flow_dir_path, 1), flow_accum_path),
        target_path_list=[flow_accum_path],
        dependent_task_list=[flow_dir_task],
        task_name='flow accmulation %s' % ws_prefix)

    # calculate slope
    slope_raster_path = os.path.join(
        ws_working_dir, '%s_slope.tif' % ws_prefix)
    calculate_slope_task = task_graph.add_task(
        func=pygeoprocessing.calculate_slope,
        args=((filled_watershed_dem_path, 1), slope_raster_path),
        target_path_list=[slope_raster_path],
        dependent_task_list=[fill_pits_task],
        task_name='calculate_slope_%s' % ws_prefix)

    clamp_slope_raster_path = os.path.join(
        ws_working_dir, '%s_clamp_slope.tif' % ws_prefix)
    clamp_slope_task = task_graph.add_task(
        func=clamp_func,
        args=(slope_raster_path, 0.005, clamp_slope_raster_path),
        target_path_list=[clamp_slope_raster_path],
        dependent_task_list=[calculate_slope_task],
        task_name='clamp_slope_%s' % ws_prefix)

    # calculate D_up
    slope_accum_watershed_dem_path = os.path.join(
        ws_working_dir, '%s_s_accum.tif' % ws_prefix)
    slope_accumulation_task = task_graph.add_task(
        func=pygeoprocessing.routing.flow_accumulation_d8,
        args=(
            (flow_dir_path, 1), slope_accum_watershed_dem_path),
        kwargs={
            'weight_raster_path_band': (clamp_slope_raster_path, 1)},
        target_path_list=[slope_accum_watershed_dem_path],
        dependent_task_list=[flow_accum_task, clamp_slope_task],
        task_name='slope_accumulation_%s' % ws_prefix)

    d_up_raster_path = os.path.join(ws_working_dir, '%s_d_up.tif' % ws_prefix)
    d_up_task = task_graph.add_task(
        func=d_up_op_func,
        args=(
            UTM_PIXEL_SIZE**2, slope_accum_watershed_dem_path,
            flow_accum_path, d_up_raster_path),
        target_path_list=[d_up_raster_path],
        dependent_task_list=[slope_accumulation_task, flow_accum_task],
        task_name='d_up_%s' % ws_prefix)

    # calculate the flow channels
    channel_path = os.path.join(ws_working_dir, '%s_channel.tif' % ws_prefix)
    threshold_flow_task = task_graph.add_task(
        func=threshold_flow_accumulation,
        args=(
            flow_accum_path, FLOW_THRESHOLD, channel_path),
        target_path_list=[channel_path],
        dependent_task_list=[flow_accum_task],
        task_name='threshold flow accum %s' % ws_prefix)

    # calculate flow path in pixels length down to stream
    pixel_flow_length_raster_path = os.path.join(
        ws_working_dir, '%s_pixel_flow_length.tif' % ws_prefix)
    downstream_flow_length_task = task_graph.add_task(
        func=pygeoprocessing.routing.distance_to_channel_d8,
        args=(
            (flow_dir_path, 1), (channel_path, 1),
            pixel_flow_length_raster_path),
        target_path_list=[
            pixel_flow_length_raster_path],
        dependent_task_list=[fill_pits_task, threshold_flow_task],
        task_name='downstream_pixel_flow_length_%s' % ws_prefix)

    # calculate real flow_path (flow length * pixel size)
    downstream_flow_distance_path = os.path.join(
        ws_working_dir, '%s_m_flow_length.tif' % ws_prefix)
    downstream_flow_distance_task = task_graph.add_task(
        func=mult_by_scalar_func,
        args=(
            pixel_flow_length_raster_path, UTM_PIXEL_SIZE, NODATA,
            downstream_flow_distance_path),
        target_path_list=[downstream_flow_distance_path],
        dependent_task_list=[downstream_flow_length_task],
        task_name='downstream_m_flow_dist_%s' % ws_prefix)

    # calculate downstream distance / downstream slope
    d_dn_per_pixel_path = os.path.join(
        ws_working_dir, '%s_d_dn_per_pixel.tif' % ws_prefix)
    d_dn_per_pixel_task = task_graph.add_task(
        func=pygeoprocessing.raster_calculator,
        args=(
            [(downstream_flow_distance_path, 1),
             (clamp_slope_raster_path, 1)],
            div_arrays, d_dn_per_pixel_path, gdal.GDT_Float32, NODATA),
        target_path_list=[d_dn_per_pixel_path],
        dependent_task_list=[
            downstream_flow_distance_task, clamp_slope_task],
        task_name='d_dn_per_pixel_%s' % ws_prefix)

    # calculate D_dn: downstream sum of distance / downstream slope
    d_dn_raster_path = os.path.join(
        ws_working_dir, '%s_d_dn.tif' % ws_prefix)
    d_dn_task = task_graph.add_task(
        func=pygeoprocessing.routing.distance_to_channel_d8,
        args=(
            (flow_dir_path, 1), (channel_path, 1), d_dn_raster_path),
        kwargs={
            'weight_raster_path_band': (d_dn_per_pixel_path, 1)
            },
        target_path_list=[d_dn_raster_path],
        dependent_task_list=[
            fill_pits_task, flow_accum_task, d_dn_per_pixel_task,
            threshold_flow_task],
        task_name='d_dn_%s' % ws_prefix)

    # calculate IC
    ic_path = os.path.join(ws_working_dir, '%s_ic.tif' % ws_prefix)
    ic_task = task_graph.add_task(
        func=pygeoprocessing.raster_calculator,
        args=(
            [(d_up_raster_path, 1), (d_dn_raster_path, 1)],
            calc_ic, ic_path, gdal.GDT_Float32, IC_NODATA),
        target_path_list=[ic_path],
        dependent_task_list=[d_up_task, d_dn_task],
        task_name='ic_%s' % ws_prefix)

    for landcover_id, (global_landcover_path, global_landcover_nodata) in (
            LANDCOVER_RASTER_PATHS.items()):
        # calculate rural population
        cur_or_fut_scenario = [
            scenario for scenario in ('2015', 'ssp1', 'ssp3', 'ssp5')
            if scenario in landcover_id]
        LOGGER.info('%s %s', landcover_id, cur_or_fut_scenario)
        if cur_or_fut_scenario:
            scenario_id = cur_or_fut_scenario[0]
            spatial_pop_2010_tot = _base_to_aligned_path_op(
                os.path.join(
                    root_data_dir, POPULATION_RASTER_PATHS['2015_tot']))
            spatial_pop_scenario_rur = _base_to_aligned_path_op(
                os.path.join(
                    root_data_dir,
                    POPULATION_RASTER_PATHS[f'{scenario_id}_rur']))
            rural_scenario_pop_path = _base_to_aligned_path_op(
                os.path.join(
                    root_data_dir, f'{scenario_id}_rural_total_pop.tif'))
            rural_pop_task = task_graph.add_task(
                func=calculate_rural_pop,
                args=(
                    pixel_area_in_km2, masked_gpw_2010_den_path,
                    spatial_pop_scenario_rur, spatial_pop_2010_tot,
                    rural_scenario_pop_path),
                target_path_list=[rural_scenario_pop_path],
                dependent_task_list=[align_resize_task, mask_gpw_2010_task],
                task_name='calculate rural pop')
        else:
            rural_scenario_pop_path = None
            rural_pop_task = None

        local_landcover_path = _base_to_aligned_path_op(
            os.path.join(root_data_dir, global_landcover_path))

        # mask local landcover
        masked_local_landcover_path = local_landcover_path.replace(
            '.tif', '_masked.tif')

        mask_landcover_task = task_graph.add_task(
            func=mask_raster_by_vector,
            args=(
                local_landcover_path, local_watershed_path,
                masked_local_landcover_path),
            kwargs={'target_nodata': global_landcover_nodata},
            target_path_list=[masked_local_landcover_path],
            dependent_task_list=[align_resize_task],
            task_name='mask lulc %s %s' % (ws_prefix, landcover_id))

        eff_n_raster_path = local_landcover_path.replace(
            '.tif', '_eff_n.tif')
        eff_n_lucode_map_nodata = eff_n_lucode_map.copy()
        eff_n_lucode_map_nodata[global_landcover_nodata] = NODATA
        reclassify_eff_n_task = task_graph.add_task(
            func=pygeoprocessing.reclassify_raster,
            args=(
                (masked_local_landcover_path, 1), eff_n_lucode_map,
                eff_n_raster_path, gdal.GDT_Float32, NODATA),
            target_path_list=[eff_n_raster_path],
            dependent_task_list=[align_resize_task, mask_landcover_task],
            task_name='reclassify_eff_n_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        load_n_lucode_map_copy = load_n_lucode_map.copy()
        load_n_lucode_map_copy[global_landcover_nodata] = NODATA
        load_n_per_ha_raster_path = local_landcover_path.replace(
            '.tif', '_load_n_per_ha.tif')
        reclassify_load_n_task = task_graph.add_task(
            func=pygeoprocessing.reclassify_raster,
            args=(
                (masked_local_landcover_path, 1), load_n_lucode_map,
                load_n_per_ha_raster_path, gdal.GDT_Float32, NODATA),
            target_path_list=[load_n_per_ha_raster_path],
            dependent_task_list=[align_resize_task, mask_landcover_task],
            task_name='reclasify_load_n_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        local_ag_load_path = _base_to_aligned_path_op(
            os.path.join(root_data_dir, AG_RASTER_PATHS[landcover_id]))

        ag_load_per_ha_path = local_landcover_path.replace(
            '.tif', '_ag_load_n_per_ha.tif')
        scenario_load_task = task_graph.add_task(
            func=calculate_ag_load,
            args=(
                load_n_per_ha_raster_path, local_ag_load_path,
                ag_load_per_ha_path),
            target_path_list=[ag_load_per_ha_path],
            dependent_task_list=[
                reclassify_load_n_task, align_resize_task],
            task_name='scenario_load_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        # calculate modified load (load * precip)
        modified_load_raster_path = local_landcover_path.replace(
            '.tif', '_%s_modified_load.tif' % landcover_id)
        local_precip_path = _base_to_aligned_path_op(
            os.path.join(root_data_dir, PRECIP_RASTER_PATHS[landcover_id]))
        modified_load_task = task_graph.add_task(
            func=modified_load,
            args=(
                ag_load_per_ha_path, local_precip_path,
                modified_load_raster_path),
            target_path_list=[modified_load_raster_path],
            dependent_task_list=[scenario_load_task, align_resize_task],
            task_name='modified_load_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        local_precip_masked_path = local_precip_path.replace(
            '.tif', '_masked.tif')
        mask_precip_task = task_graph.add_task(
            func=mask_raster_by_vector,
            args=(
                local_precip_path, local_watershed_path,
                local_precip_masked_path),
            target_path_list=[local_precip_masked_path],
            dependent_task_list=[align_resize_task],
            task_name='mask precip %s %s' % (ws_prefix, landcover_id))

        # calculate eff_i
        downstream_ret_eff_path = local_landcover_path.replace(
            '.tif', '_downstream_ret_eff.tif')
        downstream_ret_eff_task = task_graph.add_task(
            func=ipbes_ndr_analysis_cython.calculate_downstream_ret_eff,
            args=(
                (flow_dir_path, 1), (channel_path, 1), (eff_n_raster_path, 1),
                RET_LEN, downstream_ret_eff_path),
            kwargs={'temp_dir_path': ws_working_dir},
            target_path_list=[downstream_ret_eff_path],
            dependent_task_list=[
                flow_dir_task, flow_accum_task, reclassify_eff_n_task,
                threshold_flow_task],
            task_name='downstream_ret_eff_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        # calculate NDR specific values
        ndr_path = local_landcover_path.replace(
            '.tif', '_ndr.tif')
        ndr_task = task_graph.add_task(
            func=calculate_ndr,
            args=(downstream_ret_eff_path, ic_path, K_VAL, ndr_path),
            target_path_list=[ndr_path],
            dependent_task_list=[downstream_ret_eff_task, ic_task],
            task_name='ndr_task_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        n_export_raster_path = local_landcover_path.replace(
            '.tif', '_%s_n_export.tif' % (landcover_id))
        n_export_task = task_graph.add_task(
            func=mult_arrays,
            args=(
                n_export_raster_path, gdal.GDT_Float32, NODATA,
                [modified_load_raster_path, ndr_path]),
            target_path_list=[n_export_raster_path],
            dependent_task_list=[modified_load_task, ndr_task],
            task_name='n_export_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)

        target_touch_path = local_landcover_path.replace(
            '.tif', '_database_insert.txt')
        aggregate_result_task = task_graph.add_task(
            func=aggregate_to_database,
            args=(
                n_export_raster_path, modified_load_raster_path,
                rural_scenario_pop_path, local_precip_masked_path,
                load_n_per_ha_raster_path, ag_load_per_ha_path, ws_prefix,
                landcover_id, database_lock, database_path,
                target_touch_path),
            dependent_task_list=[
                n_export_task, modified_load_task, reproject_watershed_task] +
                ([rural_pop_task] if rural_pop_task else []),
            task_name='aggregate_result_%s_%s' % (ws_prefix, landcover_id),
            priority=task_id)
